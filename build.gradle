plugins {
    id "com.chrisgahlert.gradle-dcompose-plugin" version "0.5.1"
}
apply plugin: 'java'

sourceCompatibility = 1.6

repositories {
    // need to have maven central or a mirror in order for the plugin to be functional
    mavenCentral()
}

dependencies {
    compile 'org.mongodb:mongo-java-driver:3.0.0'
    testCompile 'junit:junit:4.12'
}

dcompose {
    // define the available networks
    networks {
        frontend
        backend
    }

    // A mongo service with preserved volumes (used for running the app)
    mongo {
        image = 'mongo:3.3.9'
        portBindings = ['27017']
        preserveVolumes = true
        networks = [backend]
        aliases = ['mongoalias']
    }

    // A mongo service without preserved volumes (used for running integration tests)
    mongoTest {
        image = 'mongo:3.3.9'
        portBindings = ['27017']

        // Do not include this service in the docker-compose.yml (see task createComposeFile)
        deploy = false
    }

    // The actual app image that will be built from the Dockerfile in src/main/docker
    app {
        // The baseDir will be located in the build as other generated files will be needed as well
        // and all files need to be placed inside this directory (or a subdirectory)
        baseDir = file('build/docker-app/')

        // Define the networks this service is connected to
        networks = [backend, frontend]

        // Passing in the environment variables for using the mongo service - host could be "mongo" or "mongoalias"
        env = ['MONGO_HOST=mongoalias', 'MONGO_PORT=27017']

        // Not only start the container, wait for it to finish
        waitForCommand = true

        // The container's stdout should be captured and redirected to System.out
        attachStdout = true

        // Make sure that the mongo service is launched before & stopped after the app service
        dependsOn = [mongo]
    }
}

// Make sure that the test DB container is always re-created (and therefore the old one is removed - if any)
// This is particularly useful if the previous test run was aborted (e.g. by pressing CTRL + C) and
// the test task's finalizer did not run.
createMongoTestContainer.outputs.upToDateWhen { false }

// Prepare required files for building the app image and copy them to build/docker-app/
task copyFilesToDockerBuildDir(type: Copy) {
    from jar
    from file('src/main/docker')
    from configurations.runtime
    into dcompose.app.baseDir
}

// Make sure that the copy task is executed before building the image
buildAppImage {
    dependsOn copyFilesToDockerBuildDir
}

test {
    // Start the mongo test container before running the tests
    dependsOn startMongoTestContainer

    // Clean up the container after completing the test run
    finalizedBy removeMongoTestContainer

    doFirst {
        // Pass in the configuration properties to the integration test so they can connect to the mongo test container
        systemProperty 'mongo.host', dcompose.mongoTest.dockerHost
        systemProperty 'mongo.port', dcompose.mongoTest.findHostPort(27017)
    }
    doLast {
        // Clean up the dynamic system properties in order to not mess up the UP-TO-DATE checks
        systemProperties.remove 'mongo.host'
        systemProperties.remove 'mongo.port'
    }
}

jar {
    manifest {
        attributes 'Main-Class': 'com.sample.MongoDbCounter'
    }
    from {
        // Build a fat jar with all dependencies included
        configurations.runtime.collect { it.isDirectory() ? it : zipTree(it) }
    }
}

// create a custom run task starting the app container and printing the resulting exit code
task run {
    dependsOn startAppContainer
    doLast {
        println "Java program successfully executed in docker container. Received exit code: $startAppContainer.exitCode"
    }
}
